#include <cstdlib>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <locale>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <iterator>


const std::string INDENT = "    ";
const std::string RESOURCE_CLASS = "::utils::Resource";
const std::string RESOURCE_INCLUDE = "utils/resource.hpp";


class QualifiedName {
public:
    inline QualifiedName(std::string name);

    inline auto parts() -> std::vector<std::string>&;
    inline auto parts() const -> std::vector<std::string> const&;

private:
    std::vector<std::string> m_name;
};


struct Resource {
    QualifiedName name;
    std::string file;
};


struct CliParams {
    char const* output = nullptr;
    std::vector<Resource> resources = {};
};


auto trim(std::string str) -> std::string {
    // trim start
    str.erase(str.begin(), std::find_if(str.begin(), str.end(), [](int c) {
        return !std::isspace(c);
    }));

    // trim end
    str.erase(std::find_if(str.rbegin(), str.rend(), [](int c) {
        return !std::isspace(c);
    }).base(), str.end());

    return str;
}


QualifiedName::QualifiedName(std::string name) {
    auto trimmed = trim(std::move(name));

    std::vector<std::string> parts;

    std::string::size_type begin = 0;
    std::string::size_type end = 0;

    for (; end < trimmed.size(); end++) {
        if (trimmed[end] == ':') {
            if (begin != end) {
                parts.push_back(trimmed.substr(begin, end - begin));
            }

            begin = end + 1;
        }
    }

    if (begin != end) {
        parts.push_back(trimmed.substr(begin, end - begin));
    }

    m_name = std::move(parts);
}

auto QualifiedName::parts() -> std::vector<std::string>& {
    return m_name;
}

auto QualifiedName::parts() const -> std::vector<std::string> const& {
    return m_name;
}


auto load_file(std::string const& file) -> std::vector<std::uint8_t> {
    std::ifstream in;
    in.exceptions(std::ifstream::failbit | std::ifstream::badbit);
    in.open(file, std::ifstream::in | std::ifstream::binary);

    auto src_begin = std::istreambuf_iterator<char>(in);
    auto src_end = std::istreambuf_iterator<char>();
    std::vector<std::uint8_t> buf{src_begin, src_end};

    return buf;
}

void write_resource(std::ostream& out, Resource const& resource) {
    auto const& name = resource.name.parts().back();
    auto data = load_file(resource.file);

    out << "// source: `" << resource.file << "`\n";

    // begin namespace
    for (auto it = resource.name.parts().begin(); it != resource.name.parts().end() - 1; ++it) {
        out << "namespace " << (*it) << " {\n";
    }

    // begin anonymous namespace and data array
    out << "namespace {\n\n";
    out << "const std::uint8_t " << name << "_data[] = {\n";

    // write data
    for (std::size_t i = 0; i < data.size(); i++) {
        if (i != 0) {
            out << ",\n";
        }

        std::size_t e = i + 10;

        // write data row
        out << INDENT;
        for (; i < e - 1 && i < data.size() - 1; i++) {
            out << "0x";
            out << std::hex << std::setfill('0') << std::setw(2) << static_cast<uint32_t>(data[i]);
            out << ", ";
        }
        out << "0x" << std::hex << std::setfill('0') << std::setw(2) << static_cast<uint32_t>(data[i]);
    }

    // end data array and anonymous namespace
    out << "\n};\n\n";
    out << "}   /* namespace <anonymous> */\n\n";

    // resource definition
    out << "extern const " << RESOURCE_CLASS << " " << name << "{" << name << "_data};\n\n";

    // end namespace
    for (auto it = resource.name.parts().rbegin() + 1; it != resource.name.parts().rend(); ++it) {
        out << "}   /* namespace " << (*it) << " */\n";
    }
}

void write_resources(std::ostream& out, std::vector<Resource> const& resources) {
    if (resources.empty()) {
        return;
    }

    out << "// This file has been autogenerated by `embed_resource`.\n";
    out << "\n";
    out << "#include \"" << RESOURCE_INCLUDE << "\"\n\n\n";

    for (std::size_t i = 0; i < resources.size(); i++) {
        if (i != 0) {
            out << "\n\n";
        }

        write_resource(out, resources[i]);
    }

    out << "\n";
}


int main(int argc, char** argv) {
    CliParams params;

    std::stringstream help;
    help << "Create a cpp file containing the specified resources.\n";
    help << "\n";
    help << "Usage:\n";
    help << "  " << argv[0] << " [options] (<qname> <file>)+\n";
    help << "  " << argv[0] << " -h | --help\n";
    help << "\n";
    help << "Options:\n";
    help << " -h --help                   Show this message.\n";
    help << " -o <file> --output <file>   Write to the specified file.\n";

    std::stringstream error;
    error << "Run `" << argv[0] << " --help` for help.\n";

    for (int i = 1; i < argc; i++) {
        if (std::strcmp(argv[i], "-h") == 0 || std::strcmp(argv[i], "--help") == 0) {
            std::cout << help.str();
            return 0;

        } else if (std::strcmp(argv[i], "-o") == 0 || std::strcmp(argv[i], "--output") == 0) {
            i += 1;

            if (i == argc) {
                std::cout << "Missing value for argument `" << argv[i-1] << "`\n";
                std::cout << error.str();
                return 1;
            } else {
                params.output = argv[i];
            }

        } else {
            i += 1;

            if (i == argc) {
                std::cout << "Expected a pair of `qualified name` and `file`, got single value.\n";
                std::cout << error.str();

            } else {
                char const* name = argv[i - 1];
                char const* file = argv[i];

                params.resources.push_back({QualifiedName{name}, file});
            }
        }
    }

    if (params.resources.empty()) {
        std::cout << "No resources given, exiting.\n";
        std::cout << error.str();
        return 1;
    }

    if (params.output) {
        std::ofstream out;
        out.exceptions(std::ofstream::badbit | std::ofstream::failbit);
        out.open(params.output, std::ofstream::out | std::ofstream::trunc);

        write_resources(out, params.resources);

    } else {
        write_resources(std::cout, params.resources);
    }
}
